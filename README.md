# bytecode_and_pvm.md

# Bytecode is:
# ðŸ”¸ Intermediate Instructions are generated from Python code (.py) when it is run.
# ðŸ”¸ These instructions are not understood directly by the processor, but rather by the Python virtual machine.

# ex: print("Hello")
# It is converted in the background to something like:
  # LOAD_NAME 'print'
  # LOAD_CONST 'Hello'
  # CALL_FUNCTION
# ðŸ”¸ This process is done automatically by Python when you run a script.
# ðŸ”¸ The bytecode is stored in .pyc files, which are compiled Python files.
# ðŸ”¸ These files are created in the __pycache__ directory, which is automatically generated by Python.
# ðŸ”¸ The .pyc files are used to speed up the loading of modules, as they can be loaded directly by the Python interpreter without needing to be recompiled.
# ðŸ”¸ The .pyc files are not meant to be human-readable, but they can be decompiled back into Python code using the `uncompyle6` library.

# ðŸ”¹ What is PVM (Python Virtual Machine)?
# ðŸ”¸ PVM is the runtime engine of Python.
# ðŸ”¸ It is responsible for executing the bytecode instructions generated by the Python compiler.
# ðŸ”¸ PVM is an interpreter that translates the bytecode into machine code that can be executed by the CPU.
# ðŸ”¸ PVM is platform-independent, meaning that the same bytecode can be executed on any platform that has a Python interpreter.
# ðŸ”¸ PVM is responsible for managing memory, handling exceptions, and providing access to built-in functions and libraries.
# ðŸ”¸ PVM is an integral part of the Python programming language, and it is what makes Python a high-level language.
# Convert a Python (.py) file to a Bytecode (.pyc) file

# ðŸ”¹ Summary:
# - .py âžœ Compiled to Bytecode  âžœ Stores in .pyc âžœ Interpreted and executed by PVM  âžœ  Gives you output
